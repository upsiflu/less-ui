[{"name":"Ui","comment":" Separate [State](Ui.State) and [Layout](Ui.Layout) of interface elements from the main model\nand build accessible patterns orthogonal to the Dom tree\n\n@docs Ui, Descendant\n\n\n# Create\n\n@docs html, textLabel, foliage, fromList\n\n\n# Modify\n\n@docs wrap\n\n\n# Compose\n\n@docs with\n\nTo merge two `Ui`s on the same level, use [`++`](https://package.elm-lang.org/packages/elm/core/latest/Basics#++) as in `ui1 ++ ui2`\n\n\n# View\n\n@docs view, toHtml\n\n---\n\n\n# Adding State\n\n\n### As Query parameters\n\n@docs toggle, constant, summarize, Flag, Handle\n\n\n### As Path\n\n@docs alternate, Path\n\n\n# Convenience\n\n@docs addLabel, addTextLabel\n@docs setAspect\n@docs repeat\n\nIn addition, many List functions directly work with `Ui`, for example `List.length`, `List.reverse` or `List.Extra.permutations`.\nCaveats are discussed in [Advanced Usage](advanced-usage)\n\n\n# Advanced Usage\n\nSince `Ui`s are `List`s, it is easy to use the library functions from the `List` and `List.Extra` packages.\nHowever, I recommend against it.\nThe big drawback when using `Ui`s as `List`s is that you cannot inspect (compare, filter, sort) them because the `Descendant` type is opaque.\nIt is usually easier to build exactly the `Ui` you need instead of altering and recombining them after the fact.\n\n@docs map, indexedMap, mapList\n@docs map2\n\n\n# Separating Concerns\n\n@docs application, Application, Msg\n\n\n## Decompose\n\nYou can directly use List decomposition functions such as `List.head`, `List.isEmpty`, `List.take n` etc. but\n\n@docs uncons\n\n\n# Conditional helpers\n\n@docs ifJust, notIf, none\n\n","unions":[{"name":"Descendant","comment":" ","args":["msg"],"cases":[]},{"name":"Handle","comment":" **Handle:**\n\n  - Popup -> Scene Disclosure in window - volatile - -> TODO\n  - Summarize -> Scene Disclosure inline - volatile - -> summary..details [a href=\"{currentPath}?summarize={flag}\"] <- use austinshenk/elm-w3\n  - Toggle -> Control Disclosure - persistent - -> a role=\"switch\" href=\"{currentPath}?toggle={flag}\"\n  - Constant -> Noop\n  - Alternate -> Link to path0 - -> a href=\"{path0}?rerouteLink=path1\"\n\nvolatile: `Flag`s are reset when path changes\npersistent: `Flag`s persist across path changes\nunique: A single screen has at most one such `Flag`\n\n","args":["msg"],"cases":[["Constant",["List.List (Html.Styled.Html msg)"]],["Toggle",["Ui.Flag","List.List (Html.Styled.Html Basics.Never)"]],["Summarize",["Ui.Flag","Basics.Bool -> List.List (Html.Styled.Html Basics.Never)"]],["Alternate",["( Ui.Path, Ui.Path )","List.List (Html.Styled.Html Basics.Never)"]]]},{"name":"Msg","comment":" ","args":["modelMsg"],"cases":[]}],"aliases":[{"name":"Application","comment":" ","args":["model","modelMsg"],"type":"Platform.Program () ( ( Url.Url, Browser.Navigation.Key ), model ) (Ui.Msg modelMsg)"},{"name":"Flag","comment":" [`State`](Ui.State) reflects the cumulative state of all [`Handle`](#Handle)s.\nTurning off a `Flag` renders invisible the corresponding [`Control`](Ui.Layout.Aspect) with its descendants, as well as\none-layer deep nested [`Control`s](Ui.Layout.Aspect) with their descendants.\n","args":[],"type":"String.String"},{"name":"Path","comment":" ","args":[],"type":"String.String"},{"name":"Ui","comment":" ","args":["msg"],"type":"List.List (Ui.Descendant msg)"}],"values":[{"name":"addLabel","comment":" prepend a freeform label to the contextual aspect\n","type":"Ui.Ui msg -> Ui.Ui msg -> Ui.Ui msg"},{"name":"addTextLabel","comment":" prepend a text label to the contextual aspect\n","type":"String.String -> Ui.Ui msg -> Ui.Ui msg"},{"name":"alternate","comment":" Link to `path 1`. When active, link to `path 2` instead.\nUse for unique accordion expansion, or tree-shaped scenes in general.\n\n**CSS:** `a:active`, `a:link:active`, `a:visited:active`; `a.alternate`\n\n","type":"( Ui.Path, Ui.Path ) -> List.List (Html.Styled.Html Basics.Never) -> Ui.Ui msg"},{"name":"application","comment":" Separate Url update from Model update\n","type":"{ init : ( model, Platform.Cmd.Cmd modelMsg ), update : modelMsg -> model -> ( model, Platform.Cmd.Cmd (Ui.Msg modelMsg) ), view : ( ( Url.Url, Browser.Navigation.Key ), model ) -> Browser.Document modelMsg } -> Ui.Application model modelMsg"},{"name":"constant","comment":" Here you can add your own link, button, input, or indicator.\n","type":"List.List (Html.Styled.Html msg) -> Ui.Ui msg"},{"name":"foliage","comment":" [Foliage](#Foliage) is a list of String-keyed Html\n","type":"Ui.Layout.ViewModel.Foliage msg -> Ui.Ui msg"},{"name":"fromList","comment":" `fromList = List.concatMap`\n","type":"(a -> Ui.Ui msg) -> List.List a -> Ui.Ui msg"},{"name":"html","comment":" ","type":"Html.Styled.Html msg -> Ui.Ui msg"},{"name":"ifJust","comment":" ","type":"(a -> Html.Styled.Html msg) -> Maybe.Maybe a -> Html.Styled.Html msg"},{"name":"indexedMap","comment":" Modify descendent `Ui`s according to their order.\n\n    indexedMap (\\i -> addTextLabel (String.fromInt i)) (textLabel \"I am a labeled label\")\n\n","type":"(Basics.Int -> Ui.Ui msg -> Ui.Ui msg2) -> Ui.Ui msg -> Ui.Ui msg2"},{"name":"map","comment":" Modify each descendent as a separate Ui and then recombine them.\n","type":"(Ui.Ui msg -> Ui.Ui msg2) -> Ui.Ui msg -> Ui.Ui msg2"},{"name":"map2","comment":" Combine descendents from two `Ui`s. If one `Ui` is longer, its excessive elements are dropped.\n\nYou can easily implement higher order `mapN`s:\n\n    map3 fu a b c =\n        List.map3 fu\n            (List.map List.singleton a)\n            (List.map List.singleton b)\n            (List.map List.singleton c)\n            |> List.concat\n\n","type":"(Ui.Ui msg -> Ui.Ui msg2 -> Ui.Ui msg3) -> Ui.Ui msg -> Ui.Ui msg2 -> Ui.Ui msg3"},{"name":"mapList","comment":"\n\n    List.repeat 10 []\n        |> indexedMap (\\i _ -> textLabel (String.fromInt i))\n        |> mapList (List.intersperse (textLabel \"and\"))\n\nYou may find it handy to use functions such as `List.Extra.setAt` to replace the n-th descendant in a List:\n\n    import List.Extra as List\n\n    [ textLabel \"A\", textLabel \"oops\", textLabel \"C\" ]\n        |> mapList (List.setAt 1 (textLabel \"the other B\"))\n\nor to remove a descendant:\n\n    [ textLabel \"A\", textLabel \"oops\", textLabel \"C\" ]\n        |> mapList (List.remove 1)\n\n","type":"(List.List (Ui.Ui msg) -> List.List (Ui.Ui msg2)) -> Ui.Ui msg -> Ui.Ui msg2"},{"name":"none","comment":" ","type":"Html.Styled.Html msg"},{"name":"notIf","comment":" ","type":"Basics.Bool -> Html.Styled.Html msg -> Html.Styled.Html msg"},{"name":"repeat","comment":"\n\n    repeat n =\n        List.repeat n >> List.concat\n\n","type":"Basics.Int -> Ui.Ui msg -> Ui.Ui msg"},{"name":"setAspect","comment":" Shorthand for `[] |> with ...`\n","type":"Ui.Layout.Aspect.Aspect -> Ui.Ui msg -> Ui.Ui msg"},{"name":"summarize","comment":" Prepend a summary to the scene, which the user can collapse or expand.\n\n**CSS:** `details[open]`\n\n","type":"Ui.Flag -> (Basics.Bool -> List.List (Html.Styled.Html Basics.Never)) -> Ui.Ui msg"},{"name":"textLabel","comment":" ","type":"String.String -> Ui.Ui msg"},{"name":"toHtml","comment":" If you use the default Elm Html library, this is for you\n","type":"Ui.Layout.ViewModel.Foliage msg -> Html.Html msg"},{"name":"toggle","comment":" Adds a `Flag` controlling the visibility of adjacent `Control`;\nis represented by a togglebutton in the `handle` area, so it's easy to find.\nUse for implementing a global menu: Settings, User/Avatar, `Edit` button...\n\n**CSS:** `a[role=\"switch\"]:aria-checked`\n\n","type":"Ui.Flag -> List.List (Html.Styled.Html Basics.Never) -> Ui.Ui msg"},{"name":"uncons","comment":" Attempt to separate the first descendant in the Ui.\n","type":"Ui.Ui msg -> Maybe.Maybe ( Ui.Ui msg, Ui.Ui msg )"},{"name":"view","comment":" Generate [keyed Html (Foliage)](Ui.Layout.ViewModel#Foliage)\n","type":"Url.Url -> Maybe.Maybe Ui.Layout.Layout -> Ui.Ui msg -> Ui.Layout.ViewModel.Foliage msg"},{"name":"with","comment":" Nest a sub-Ui to each descendant, via a [semantic aspect](Ui.Layout.Aspect):\n\n  - [`Handle`](#Handle) (Avatars, view-options, hamburger icon...)\n  - [`Scene`](Ui.Layout.Aspect) (the objects of interest)\n  - [`Control`](Ui.Layout.Aspect) (tools and config sheet)\n  - [`Info`](Ui.Layout.Aspect) (snacks and status)\n\n","type":"Ui.Layout.Aspect.Aspect -> Ui.Ui msg -> Ui.Ui msg -> Ui.Ui msg"},{"name":"wrap","comment":" Nest the DOM here.\nIf you wrap, and then define the contextual aspect,\nthe wrapper will wrap all descendants that constitute this aspect.\n\n    example : Ui msg\n    example =\n        []\n            |> with Scene []\n            |> wrap ((++) ( \"message\", Html.text \"I am wrapped\" ))\n            |> with Control []\n\nNow, let's see what happens if we define a contextual aspect.\n\n    []\n        |> with Control example\n\nThis will output:\n`Scene -> []`,\n`Control -> \"I am wrapped\" []`\n\n","type":"(Ui.Layout.ViewModel.Foliage msg -> Ui.Layout.ViewModel.Foliage msg) -> Ui.Ui msg -> Ui.Ui msg"}],"binops":[]},{"name":"Ui.Get","comment":" This is a very simple dictionary type with `Aspect` as key.\n\n@docs Get\n\n\n# Create\n\n@docs empty, full, singleton\n\n\n# Associate values\n\n@docs orAdd, insert, update, updateValue\n@docs addValue, addWithDefault, maybeAdd\n\n\n### Add to `Get (List a)`\n\n@docs consList, addList\n\n\n# Map\n\n@docs map, mapValue, map2, map2WithDefaults, map2Value, filter\n\n\n### Map with respect to the key\n\n@docs mapByKey, mapValueByKey, map2ByKey\n\n\n### Map `Get (List a)`\n\n@docs concat\n\n\n### Map `Get (Get a)`\n\n@docs join, unlockInner, unlockOuter\n\n\n# Compose\n\n\n### Or\n\n@docs orElse\n\n\n### Chain\n\n@docs andThen, andThenFlat, andThenMaybe, andMap, andMapFlat\n\n\n# Query\n\n@docs member, get, andGet, withDefault\n\n\n# Lists\n\n@docs toList, toListBy, keys, values, fromList, fromListBy\n\n\n### Convenience functions for `Get (List a)`\n\n@docs consLists, concatLists\n\n\n### Folding\n\n@docs sequence\n\n","unions":[],"aliases":[{"name":"Get","comment":" ","args":["a"],"type":"Ui.Layout.Aspect.Aspect -> Maybe.Maybe a"}],"values":[{"name":"addList","comment":" `addWithDefault [] (++)`\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n    addList Scene [1, 2] (full [3, 4])\n        |> get Scene\n        --> Just [1, 2, 3, 4]\n\n    addList Scene [1, 2] (full [3, 4])\n        |> get Control\n        --> Just [3, 4]\n\n","type":"Ui.Layout.Aspect.Aspect -> List.List a -> Ui.Get.Get (List.List a) -> Ui.Get.Get (List.List a)"},{"name":"addValue","comment":" Consider `Nothing` in the `add` composer so that the composition can't fail\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n\n    mapLists : (List a -> List a -> List a) -> Maybe (List a) -> Maybe (List a) -> List a\n    mapLists fu ma mb =\n        fu (Maybe.withDefault [] ma) (Maybe.withDefault [] mb)\n\n\n    singleton Control [3]\n        |> addValue (mapLists (++)) Scene [1, 2]\n        |> get Scene\n            --> Just [1, 2]\n\n    singleton Control [3]\n        |> addValue (mapLists (++)) Scene [1, 2]\n        |> get Control\n            --> Just [3]\n\n    singleton Control [3]\n        |> addValue (mapLists (++)) Scene [1, 2]\n        |> addValue (mapLists (++)) Scene [0]\n        |> get Scene\n            --> Just [0, 1, 2]\n\n    full 1\n        |> addValue (Maybe.map2 (+)) Scene 1\n        |> get Scene\n            --> Just (Just 2)\n\n    empty\n        |> addValue (Maybe.map2 (+)) Scene 1\n        |> get Scene\n            --> Just Nothing\n\n","type":"(Maybe.Maybe a -> Maybe.Maybe b -> c) -> Ui.Layout.Aspect.Aspect -> a -> Ui.Get.Get b -> Ui.Get.Get c"},{"name":"addWithDefault","comment":" Define a default so that the composition can't fail\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n    addWithDefault 0 (+) Scene 1 (full 2)\n        |> get Scene\n        --> Just 3\n\n    addWithDefault 0 (+) Scene 1 empty\n        |> get Scene\n        --> Just 1\n\n","type":"a -> (a -> a -> b) -> Ui.Layout.Aspect.Aspect -> a -> Ui.Get.Get a -> Ui.Get.Get b"},{"name":"andGet","comment":" ","type":"Ui.Layout.Aspect.Aspect -> Maybe.Maybe (Ui.Get.Get a) -> Maybe.Maybe a"},{"name":"andMap","comment":" Map the result of the first `get` to the next `get`\n","type":"Ui.Get.Get (a -> b) -> Ui.Get.Get a -> Ui.Get.Get (Ui.Get.Get b)"},{"name":"andMapFlat","comment":" like `andMap`, but apply the same key twice\n","type":"Ui.Get.Get (a -> b) -> Ui.Get.Get a -> Ui.Get.Get b"},{"name":"andThen","comment":" get `get b` from the result of `get a`\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n    full 2\n        |> andThen (negate >> singleton Scene)\n        |> get Control\n        |> andGet Scene\n        --> Just (-2)\n\n","type":"(a -> Ui.Get.Get b) -> Ui.Get.Get a -> Ui.Get.Get (Ui.Get.Get b)"},{"name":"andThenFlat","comment":" Applies the same key twice to unlock a nested `Get`\n\n`andThenFlat = andThen >> (<<) join`\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n    full 2\n        |> andThenFlat (negate >> singleton Scene)\n        |> get Scene\n        --> Just (-2)\n\n","type":"(a -> Ui.Get.Get b) -> Ui.Get.Get a -> Ui.Get.Get b"},{"name":"andThenMaybe","comment":" Like `andThen`, but you supply a fallible creator function\n","type":"(a -> Maybe.Maybe (Ui.Get.Get b)) -> Ui.Get.Get a -> Ui.Get.Get (Ui.Get.Get b)"},{"name":"concat","comment":" interprets Nothing as []\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n    singleton Scene [1]\n        |> concat (singleton Scene [2, 3])\n        |> get Scene\n            --> Just [2, 3, 1]\n\n    full [1]\n        |> concat (singleton Scene [2, 3])\n        |> get Control\n            --> Just [1]\n\n","type":"Ui.Get.Get (List.List a) -> Ui.Get.Get (List.List a) -> Ui.Get.Get (List.List a)"},{"name":"concatLists","comment":" `concatLists = fromListBy addList`\n","type":"List.List ( Ui.Layout.Aspect.Aspect, List.List a ) -> Ui.Get.Get (List.List a)"},{"name":"consList","comment":"\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n    consList Scene 1 (full [2, 3])\n        |> get Scene\n        --> Just [1, 2, 3]\n\nImplicitly creates a list if key has no value yet:\n\n    consList Scene \"a\" empty\n        |> get Scene\n            --> Just [\"a\"]\n\n","type":"Ui.Layout.Aspect.Aspect -> a -> Ui.Get.Get (List.List a) -> Ui.Get.Get (List.List a)"},{"name":"consLists","comment":" `consLists = fromListBy consList`\n","type":"List.List ( Ui.Layout.Aspect.Aspect, a ) -> Ui.Get.Get (List.List a)"},{"name":"empty","comment":" in any case, return Nothing\n","type":"Ui.Get.Get a"},{"name":"filter","comment":" only get a value if the condition holds\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n    singleton Scene 1\n        |> insert Control 2\n        |> insert Info 1\n        |> filter ((==) 1)\n        |> toList [Scene, Info, Control]\n        --> [(Scene, 1), (Info, 1)]\n\n","type":"(a -> Basics.Bool) -> Ui.Get.Get a -> Ui.Get.Get a"},{"name":"fromList","comment":" `orAdd`s from the list but skips duplicate keys.\n`fromList = fromListWith orAdd`\n\nIf you want to modify the behavior on duplicate keys, use `fromListWith`\nor `consList`.\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n    fromList [(Scene, \"Scene 1\"), (Scene, \"Scene 2\"), (Control, \"C\")]\n        |> toList [Scene, Control]\n        --> [(Scene, \"Scene 1\"), (Control, \"C\")]\n\n","type":"List.List ( Ui.Layout.Aspect.Aspect, a ) -> Ui.Get.Get a"},{"name":"fromListBy","comment":" ","type":"(Ui.Layout.Aspect.Aspect -> a -> Ui.Get.Get b -> Ui.Get.Get b) -> List.List ( Ui.Layout.Aspect.Aspect, a ) -> Ui.Get.Get b"},{"name":"full","comment":" in any case, return `a`\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n    full 1\n        |> get Scene\n        --> Just 1\n\n","type":"a -> Ui.Get.Get a"},{"name":"get","comment":" `(|>)`\n","type":"key -> (key -> value) -> value"},{"name":"insert","comment":" insert at key, overwriting existing value\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n    singleton Scene 1\n        |> insert Scene 2\n        |> get Scene\n            --> Just 2\n\n    singleton Control 1\n        |> insert Scene 2\n        |> get Scene\n            --> Just 2\n\n","type":"Ui.Layout.Aspect.Aspect -> a -> Ui.Get.Get a -> Ui.Get.Get a"},{"name":"join","comment":" Apply the same key twice\n","type":"Ui.Get.Get (Ui.Get.Get a) -> Ui.Get.Get a"},{"name":"keys","comment":" ","type":"List.List Ui.Layout.Aspect.Aspect -> Ui.Get.Get a -> List.List Ui.Layout.Aspect.Aspect"},{"name":"map","comment":" compose a function behind the result\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n    map negate (full 1)\n        |> get Scene\n        --> Just (-1)\n\n","type":"(a -> b) -> Ui.Get.Get a -> Ui.Get.Get b"},{"name":"map2","comment":" Compose a function behind the results of two `Get`s,\nboth with the identical key.\nNote that if any of the two values is Nothing, the other is ignored.\n\nExample:\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n    map2 (::) (singleton Scene 1) (singleton Scene [2, 3])\n        |> get Scene\n        --> Just [1, 2, 3]\n\n","type":"(a -> b -> c) -> Ui.Get.Get a -> Ui.Get.Get b -> Ui.Get.Get c"},{"name":"map2ByKey","comment":" ","type":"(Ui.Layout.Aspect.Aspect -> a -> b -> c) -> Ui.Get.Get a -> Ui.Get.Get b -> Ui.Get.Get c"},{"name":"map2Value","comment":" Never fail\n","type":"(Maybe.Maybe a -> Maybe.Maybe b -> c) -> Ui.Get.Get a -> Ui.Get.Get b -> Ui.Get.Get c"},{"name":"map2WithDefaults","comment":" ","type":"a -> (a -> a -> b) -> Ui.Get.Get a -> Ui.Get.Get a -> Ui.Get.Get b"},{"name":"mapByKey","comment":" ","type":"(Ui.Layout.Aspect.Aspect -> a -> b) -> Ui.Get.Get a -> Ui.Layout.Aspect.Aspect -> Maybe.Maybe b"},{"name":"mapValue","comment":" compose a function behind the result, preserving the 'Maybe' value.\n\n    mapValue =\n        (<<)\n\nYou can use this function to leverage mapping functions from the `Maybe` and `Maybe.Extra` library.\nFor example, `filter` can be expressed as `Maybe.filter >> mapValue`.\n\n","type":"(Maybe.Maybe a -> Maybe.Maybe b) -> Ui.Get.Get a -> Ui.Get.Get b"},{"name":"mapValueByKey","comment":" ","type":"(Ui.Layout.Aspect.Aspect -> Maybe.Maybe a -> Maybe.Maybe b) -> Ui.Get.Get a -> Ui.Layout.Aspect.Aspect -> Maybe.Maybe b"},{"name":"maybeAdd","comment":" insert at key, combining with existing value\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n    singleton Control [3]\n        |> maybeAdd (++) Scene [1, 2]\n        |> get Scene\n            --> Nothing\n\n    singleton Scene \"b\"\n        |> maybeAdd (++) Scene \"a\"\n        |> get Scene\n            --> Just \"ab\"\n\n    singleton Control 4\n        |> maybeAdd (+) Control 5\n        |> get Control\n            --> Just 9\n\n","type":"(a -> b -> c) -> Ui.Layout.Aspect.Aspect -> a -> Ui.Get.Get b -> Ui.Get.Get c"},{"name":"member","comment":" Example:\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n    singleton Scene 1\n        |> member Scene --> True\n\n    singleton Control 1\n        |> member Scene -> False\n\n","type":"Ui.Layout.Aspect.Aspect -> Ui.Get.Get a -> Basics.Bool"},{"name":"orAdd","comment":" insert at key if not yet populated\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n    singleton Scene \"a\"\n        |> orAdd Scene \"b\"\n        |> orAdd Control \"c\"\n        |> orAdd Control \"d\" -- ignored because Control has been populated\n        |> get Control\n            --> Just \"c\"\n\n","type":"Ui.Layout.Aspect.Aspect -> a -> Ui.Get.Get a -> Ui.Get.Get a"},{"name":"orElse","comment":" returns the first parameter if the second fails, using the same key. Lazy.\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n    let\n        getMy =\n            empty\n                |> orElse (singleton Info \"b\")\n                |> orElse (singleton Scene \"a\")\n                |> orElse (singleton Scene \"c\")\n    in\n    (getMy Scene, getMy Control)\n    --> ( Just \"a\",  Nothing)\n\n","type":"Ui.Get.Get a -> Ui.Get.Get a -> Ui.Layout.Aspect.Aspect -> Maybe.Maybe a"},{"name":"sequence","comment":" Apply a sequence of operations on a `Get`:\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n    singleton Scene 1\n        |> sequence\n            [ map ((*) 2)\n            , filter (modBy 2 >> (==) 0)\n            , map ((+) 1)\n            ]\n        |> get Scene\n        --> Just 3\n\n","type":"List.List (Ui.Get.Get a -> Ui.Get.Get a) -> Ui.Get.Get a -> Ui.Get.Get a"},{"name":"singleton","comment":" ","type":"Ui.Layout.Aspect.Aspect -> a -> Ui.Get.Get a"},{"name":"toList","comment":"\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n    full \"Hello\"\n        |> toList [Scene, Control]\n        --> [(Scene, \"Hello\"), (Control, \"Hello\")]\n\n","type":"List.List Ui.Layout.Aspect.Aspect -> Ui.Get.Get a -> List.List ( Ui.Layout.Aspect.Aspect, a )"},{"name":"toListBy","comment":" ","type":"Ui.Get.Get (a -> b) -> List.List Ui.Layout.Aspect.Aspect -> Ui.Get.Get a -> List.List b"},{"name":"unlockInner","comment":" `get` the inner `Get` with the given key\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n","type":"Ui.Layout.Aspect.Aspect -> Ui.Get.Get (Ui.Get.Get a) -> Ui.Get.Get a"},{"name":"unlockOuter","comment":" `get` the outer `Get` with the given key\n","type":"Ui.Layout.Aspect.Aspect -> Ui.Get.Get (Ui.Get.Get a) -> Ui.Get.Get a"},{"name":"update","comment":" Update the value associated with a specified key, if present\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n    singleton Scene \"a\"\n        |> update Scene String.toUpper\n        |> get Scene\n\n    --> Just \"A\"\n\n    singleton Scene \"a\"\n        |> update Control String.toUpper\n        |> get Scene\n\n    --> Just \"a\"\n\n    empty\n        |> update Scene ((+) 1)\n        |> get Scene\n\n    --> Nothing\n\n","type":"Ui.Layout.Aspect.Aspect -> (a -> a) -> Ui.Get.Get a -> Ui.Get.Get a"},{"name":"updateValue","comment":" ","type":"Ui.Layout.Aspect.Aspect -> (Maybe.Maybe a -> Maybe.Maybe a) -> Ui.Get.Get a -> Ui.Get.Get a"},{"name":"values","comment":"\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n    values [Scene, Control] (full 2) --> [2, 2]\n\n","type":"List.List Ui.Layout.Aspect.Aspect -> Ui.Get.Get a -> List.List a"},{"name":"withDefault","comment":" Note that, strictly speaking, you no longer have a `Get` after applying `withDefault`.\n\n    import Ui.Layout.Aspect exposing (Aspect(..))\n\n    empty\n        |> withDefault \"default\"\n        |> get Scene\n        --> \"default\"\n\n","type":"a -> Ui.Get.Get a -> Ui.Layout.Aspect.Aspect -> a"}],"binops":[]},{"name":"Ui.Layout","comment":" Lay out the [`ViewModel`](Ui.Layout.ViewModel)\n\n@docs Layout\n\n\n# View\n\n@docs view\n\n","unions":[{"name":"Layout","comment":" ","args":[],"cases":[["Default",[]]]}],"aliases":[],"values":[{"name":"view","comment":" ","type":"Ui.Layout.ViewModel.ViewModel msg -> Ui.Layout.Layout -> Ui.Layout.ViewModel.Foliage msg"}],"binops":[]},{"name":"Ui.Layout.Aspect","comment":"\n\n@docs Aspect\n\n","unions":[{"name":"Aspect","comment":"\n\n  - control: global toolbar or property sheet\n  - info: statusbar, help screen, or tooltip bubbles\n  - scene: the item's editable contents and overlays\n\n","args":[],"cases":[["Scene",[]],["Control",[]],["Info",[]]]}],"aliases":[],"values":[],"binops":[]},{"name":"Ui.Layout.ViewModel","comment":" Intermediate model before applying a [Layout](Ui.Layout)\n\n@docs ViewModel, Foliage\n\n\n# Create\n\n@docs empty\n\n\n# Map\n\n@docs mapGet, mapHandle\n\n\n# Compose\n\n@docs merge\n\n","unions":[],"aliases":[{"name":"Foliage","comment":" ","args":["msg"],"type":"List.List ( String.String, Html.Styled.Html msg )"},{"name":"ViewModel","comment":" ","args":["msg"],"type":"{ handle : Ui.Layout.ViewModel.Foliage msg, get : Ui.Get.Get (Ui.Layout.ViewModel.Foliage msg) }"}],"values":[{"name":"empty","comment":" ","type":"Ui.Layout.ViewModel.ViewModel msg"},{"name":"mapGet","comment":" ","type":"(Ui.Get.Get (Ui.Layout.ViewModel.Foliage msg) -> Ui.Get.Get (Ui.Layout.ViewModel.Foliage msg)) -> Ui.Layout.ViewModel.ViewModel msg -> Ui.Layout.ViewModel.ViewModel msg"},{"name":"mapHandle","comment":" ","type":"(Ui.Layout.ViewModel.Foliage msg -> Ui.Layout.ViewModel.Foliage msg) -> Ui.Layout.ViewModel.ViewModel msg -> Ui.Layout.ViewModel.ViewModel msg"},{"name":"merge","comment":" combines two ViewModels into one, concatenating its contents.\n\n    import Ui.Aspect exposing (Aspect(..))\n\n    merge\n        { handle = [], get = Get.singleton Scene [] }\n        { handle = [], get = Get.singleton Scene [] }\n        |> {get} -> get Scene\n    --> []\n\n","type":"Ui.Layout.ViewModel.ViewModel msg -> Ui.Layout.ViewModel.ViewModel msg -> Ui.Layout.ViewModel.ViewModel msg"}],"binops":[]},{"name":"Ui.Mask","comment":"\n\n@docs Mask\n\n\n# Create\n\n@docs transparent, opaque\n@docs occlude, occludeList\n\n\n# Compose\n\n_Note that Masks are functions so you can compose them easily:_\n\n`mask0 >> mask1` : combine two masks (occlusions accumulate, of course)\n\n`mask0 get0` : apply a mask to a `get`\n\n@docs concat\n\n\n# Modify\n\n@docs mapSecond\n\n","unions":[],"aliases":[{"name":"Mask","comment":" ","args":["a"],"type":"Ui.Get.Get a -> Ui.Get.Get a"}],"values":[{"name":"concat","comment":" combine a list of masks to a single masks. Nothing if list is empty.\n","type":"List.List (Ui.Mask.Mask a) -> Ui.Mask.Mask a"},{"name":"mapSecond","comment":" ","type":"(a -> b) -> Ui.Mask.Mask a -> Ui.Get.Get a -> Ui.Get.Get b"},{"name":"occlude","comment":" occlude an aspect\n","type":"Ui.Layout.Aspect.Aspect -> Ui.Get.Get a -> Ui.Get.Get a"},{"name":"occludeList","comment":" Occlude a list of aspects\n","type":"List.List Ui.Layout.Aspect.Aspect -> Ui.Mask.Mask a"},{"name":"opaque","comment":" ","type":"Ui.Mask.Mask a"},{"name":"transparent","comment":" ","type":"Ui.Mask.Mask a"}],"binops":[]}]